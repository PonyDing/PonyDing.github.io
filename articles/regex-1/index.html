<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="description" content="Keep learning.">


    <meta name="keywords" content="Python,Distributed Computing,AI">


<title>小白的正则表达式学习之路——基础篇 | DingZhi&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">DingZhi&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">DingZhi&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3c2cb6a51b306a50c53ae432e39de395";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">小白的正则表达式学习之路——基础篇</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Ding Zhi</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 16, 2019&nbsp;&nbsp;0:05:03</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/面向对象程序设计/">面向对象程序设计</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>正则表达式在几乎所有语言中都可以使用，无论是前端的JavaScript、还是后端的Java、c#。他们都提供相应的接口/函数支持正则表达式。但很神奇的是：<strong><em>无论在学校选择哪一门计算机语言，都没有关于正则表达式的课程供你修读，在你学会正则之前，你只能看着那些正则大师们，写了仅仅一行外星文似的字符串，替代了你数十行大篇幅的if-else代码来做的一系列数据校验</em></strong>。</p>
</blockquote>
<p>以前我对于正则表达式一直是浅尝辄止，只是简单了解一些基本规则和性质，但对它的认识并不系统。今天我系统研究了正则表达式的知识体系，对它有了新的认识。下面我就与大家分享我的正则表达式学习历程。</p>
<blockquote class="pullquote left"><p><em>Regular expression is a group of characters or symbols which is used to find a specific pattern from a text.</em><br><em>正则表达式是一组由字母和符号组成的特殊文本, 它可以用来从文本中找出满足你想要的格式的句子.</em></p>
</blockquote>
<p>最近两天在刷GitHub时遇到了一个名为<a href="https://github.com/ziishaned/learn-regex" 点我查看"" target="_blank" rel="noopener"><strong>learn-regex</strong></a>的项目，是一个有关正则表达式的不错的新手入门教程，这份教程拥有中文版汉化材料，很方便我们阅读与学习，此外，这个项目之所以能获得2万星的高赞，还有一个重要的原因就是它提供了配套的<a href="https://regex101.com" 点我查看"" target="_blank" rel="noopener"><strong>在线练习平台</strong></a>，每一个案例都可以在练习平台中输入，这个平台直观地展示了正则表达式的匹配方式。我根据这份教程和其它材料，简单研究了正则表达式。并在这里对我的学习笔记进行记录，并将我的学习心得与大家进行分享。下面的这篇博客是我在<a href="https://github.com/ziishaned/learn-regex" 点我查看"" target="_blank" rel="noopener"><strong>learn-regex</strong></a>项目文档上结合其它材料进行批注和适当修改后产生的。下面为我们就将开始正式探索正则表达式了。研究正则表达式，首先应该了解其内涵，一个正则表达式是在一个主体字符串中从左到右匹配字符串时的一种样式.例如”Regular expression”是一个完整的句子, 但我们常使用缩写的术语”regex”或”regexp”.正则表达式可以用来替换文本中的字符串,验证形式,提取字符串等等.</p>
<p>先看一个引例：想象这样一个场景——你正在写一个应用, 你想设定一个用户命名的规则, 让用户名包含字符,数字,下划线和连字符,以及限制字符的个数,好让名字看起来没那么丑.<br>我们使用以下正则表达式来验证一个用户名，那么这个正则表达式可以接受 <code>john_doe</code>, <code>jo-hn_doe</code>, <code>john12_as</code>，但不匹配<code>Jo</code>, 因为它包含了大写的字母而且太短了.通过这个案例，我们对正则表达式有了一个直观的认识。下面我们一起进行进一步地深入探索。</p>
<p><img src="https://github.com/ziishaned/learn-regex/blob/master/img/regexp-cn.png?raw=true" alt="Regular expression"></p>
<h2 id="regex101平台介绍"><a href="#regex101平台介绍" class="headerlink" title="regex101平台介绍"></a><a href="https://regex101.com" 点我查看"" target="_blank" rel="noopener"><strong>regex101平台</strong></a>介绍</h2><p>为了提升学习效果，我们有必要对本项目自带的这一在线平台进行高效利用，以期达到事半功倍的效果。</p>
<p>例如：为了探索<code>(c|g|p)ar</code>是如何匹配<code>The car is parked in the garage.</code>这句话中的几个单词的,我们可以在平台上对应进行输入：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9426074afae2b9d7f46408bf34be339d_hd.jpg" alt="img"></p>
<p>我们可以直观地看到以c、g、p开头并且紧跟ar的单词都能很正则表达式匹配。网页的右侧还会给出相应的解释：</p>
<p><img src="https://pic2.zhimg.com/50/v2-9434007d1d439e37dd7aacb30864b3a8_hd.jpg" alt="img">是不是比枯燥的文字解释要生动很多呢？我们可以在平台上输入一系列字符串，以达到更好的练习效果，也能更好地理解正则表达式每一个规则的含义。下面我们就从基本匹配规则开始，一起来研究正则表达式吧！</p>
<h2 id="Regex的基本匹配规则"><a href="#Regex的基本匹配规则" class="headerlink" title="Regex的基本匹配规则"></a>Regex的基本匹配规则</h2><p>正则表达式其实就是在执行搜索时的格式, 它由一些字母和数字组合而成。例如正则表达式<code>123</code>匹配字符串<code>123</code>. 它逐个字符的与输入的正则表达式做比较。这样的说法也许比较抽象和难于理解，下面有较为清晰地一组案例：</p>
<p>例如: 一个正则表达式 <code>the</code>, 它表示一个规则: 由字母<code>t</code>开始,接着是<code>h</code>,再接着是<code>e</code>.</p>
<pre>
"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat. 
</pre>

<blockquote>
<p>这里值得指出的一点是，正则表达式是大小写敏感的, 所以<code>The</code>不会匹配<code>the</code>.</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>
</blockquote>
<h2 id="Regex中的元字符"><a href="#Regex中的元字符" class="headerlink" title="Regex中的元字符"></a>Regex中的元字符</h2><p>*<em>正则表达式主要依赖于元字符. *</em> 元字符不代表他们本身的字面意思, 他们都有特殊的含义. 一些元字符写在方括号中的时候有一些特殊的意思. 以下是一些元字符的介绍:</p>
<table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="left">句号匹配任意单个字符，<strong>除了换行符.</strong></td>
</tr>
<tr>
<td align="center">[ ]</td>
<td align="left">字符种类. 匹配方括号内的<strong>任意字符.</strong></td>
</tr>
<tr>
<td align="center">[^ ]</td>
<td align="left">否定的字符种类. 匹配<strong>除了方括号里的任意字符</strong></td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">匹配&gt;=0个重复的在*号之前的字符.</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">匹配&gt;=1个重复的+号前的字符.</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">标记?之前的字符为<strong>可选.</strong></td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">匹配num个大括号之前的字符 (n &lt;= num &lt;= m).</td>
</tr>
<tr>
<td align="center">(xyz)</td>
<td align="left">字符集,<strong>匹配与 xyz 完全相等的字符串.</strong></td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">或运算符,<strong>匹配符号前或后的字符.</strong></td>
</tr>
<tr>
<td align="center">\</td>
<td align="left"><strong>转义字符</strong>,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">从开始行开始匹配.<em>开始标记</em></td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">从末端开始匹配.<em>结束标记</em></td>
</tr>
</tbody></table>
<blockquote>
<p>现在将这个表格配合文章开头的引例进行对比，我们对正则表达式的理解就深入了一层。下面我们将分别探讨这些元字符的功能和使用。</p>
</blockquote>
<h3 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符."></a>点运算符<code>.</code></h3><p><code>.</code>匹配任意单个字符, 但不匹配换行符. </p>
<p>例如, 表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串.</p>
<pre>
".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集[ ]"></a>字符集<code>[ ]</code></h3><p>方括号用来指定一个字符集. 在方括号中使用连字符来指定字符集的范围. <strong>方括号中的字符集与顺序无关.</strong></p>
<p> 例如, 表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>.</p>
<pre>
"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<h4 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h4><p>前文谈及在正则表达式中 <code>^</code> 是字符串开始标记, 但<font color="red"><strong>当它用在方括号最前面时, 表示对方括号中字符集取反.</strong></font></p>
<p>例如, 表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符.</p>
<pre>
"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<h3 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h3><p>在重复次数后加上元字符 <code>+</code>, <code>*</code> or <code>?</code> , 可以指定匹配子模式的次数.</p>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符*"></a>元字符<code>*</code></h4><p><code>*</code>号匹配 在<code>*</code>之前的字符<strong>出现大于等于0次.</strong></p>
<p>例如, 表达式 <code>a*</code> 匹配以0或更多个a开头的字符, 因为有0个这个条件, 其实也就匹配了所有的字符. 表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串.</p>
<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>

<p>前已述及，<code>.</code>字符可以匹配任意字符，那么不难得知，<font color="red"><strong><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>.</strong></font></p>
<p><code>*</code>和表示匹配空格的符号<strong><code>\s</code></strong>连起来用, 如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串.</p>
<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.
</pre>

<h4 id="元字符-1"><a href="#元字符-1" class="headerlink" title="元字符+"></a>元字符<code>+</code></h4><p><code>+</code>号匹配<code>+</code>号之前的字符出现** &gt;=1 次.**<br>例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾,中间跟着任意个字符的字符串.</p>
<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

<h4 id="元字符-2"><a href="#元字符-2" class="headerlink" title="元字符?"></a>元字符<code>?</code></h4><p>元字符 <code>?</code> 标记意为在符号前面的字符为<strong>可选, 即出现 0 或 1 次.</strong><br>例如, 表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>.</p>
<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

<h3 id="元字符-3"><a href="#元字符-3" class="headerlink" title="元字符{}"></a>元字符<code>{}</code></h3><p>正则表达式中 <code>{}</code> 用来描述一个或一组字符可以重复出现的次数范围.</p>
<p>例如,  表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字.</p>
<pre>
"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p>在上面的案例中，若省略掉第二个参数，那么得到的<code>[0-9]{2,}</code> 表示匹配至少两位 0~9 的数字.</p>
<pre>
"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.
</pre>

<p>如果省略掉第二个参数和逗号，则表示重复固定的次数.针对上个案例，我们可以得到 <code>[0-9]{3}</code>，它匹配3位数字</p>
<pre>
"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.
</pre>

<h3 id="特征标群"><a href="#特征标群" class="headerlink" title="(...) 特征标群"></a><code>(...)</code> 特征标群</h3><p>特征标群是一组写在 <code>(...)</code> 中的子模式. </p>
<p>这句定义比较难于理解，下面我们结合案例分析就容易明白了：之前我们讨论的 <code>{}</code> 可表示前面一个字符出现指定次数. 但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次. 例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>.</p>
<blockquote>
<p>通俗的说，特征标群的括号就相当于相当于数学课上<code>()</code>的作用，也就是让括号内的部分成为了一个整体参与运算。</p>
</blockquote>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或. 例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p>
<pre>
"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.
</pre>

<h3 id="或运算符"><a href="#或运算符" class="headerlink" title="| 或运算符"></a><code>|</code> 或运算符</h3><p>或运算符就表示或, 用作判断条件.</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>.也就是匹配<code>the</code>,<code>The</code>和<code>car</code></p>
<pre>
"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符. 用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符. 如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>.</p>
<blockquote>
<p>这里的转义字符与C语言中的用法类似。</p>
</blockquote>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的. 如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<pre>
"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<h3 id="锚点符号"><a href="#锚点符号" class="headerlink" title="锚点符号"></a>锚点符号</h3><p>在正则表达式中, 锚点用于匹配指定开头或结尾的字符串—— <code>^</code> 指定开头, <code>$</code> 指定结尾.</p>
<h4 id="号"><a href="#号" class="headerlink" title="^ 号"></a><code>^</code> 号</h4><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头.</p>
<p>例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>. 但如果使用 <code>^b</code> 将匹配不到任何结果. 因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头.</p>
<p>例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串.</p>
<pre>
"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.
</pre>

<pre>
"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>

<blockquote>
<p>不难看出，这里第二个案例中the并没有被匹配，可以通过这一组对比直观的认识到<code>^</code>符号的匹配效果。</p>
</blockquote>
<h4 id="号-1"><a href="#号-1" class="headerlink" title="$ 号"></a><code>$</code> 号</h4><p> <code>$</code> 号用来匹配字符是否为字符串末尾。</p>
<p>例如, <code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串.</p>
<pre>
"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<pre>
"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a>
</pre>

<h2 id="由转义字符构成的简写字符集"><a href="#由转义字符构成的简写字符集" class="headerlink" title="由转义字符构成的简写字符集"></a>由转义字符构成的简写字符集</h2><p>正则表达式提供一些常用的字符集简写如下，理解方式与C语言中类似，特将表格列在下方，不再赘述其含义与用法。</p>
<table>
<thead>
<tr>
<th align="center">简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td align="center">\w</td>
<td>匹配所有字母数字, 等同于 <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td align="center">\W</td>
<td>匹配所有非字母数字, 即符号, 等同于: <code>[^\w]</code></td>
</tr>
<tr>
<td align="center">\d</td>
<td>匹配数字: <code>[0-9]</code></td>
</tr>
<tr>
<td align="center">\D</td>
<td>匹配非数字: <code>[^\d]</code></td>
</tr>
<tr>
<td align="center">\s</td>
<td>匹配所有空格字符, 等同于: <code>[\t\n\f\r\p{Z}]</code></td>
</tr>
<tr>
<td align="center">\S</td>
<td>匹配所有非空格字符: <code>[^\s]</code></td>
</tr>
<tr>
<td align="center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td align="center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td align="center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td align="center">\p</td>
<td>匹配 CR/LF (等同于 <code>\r\n</code>)，用来匹配 DOS 行终止符</td>
</tr>
</tbody></table>
<h2 id="零宽度断言-前后预查"><a href="#零宽度断言-前后预查" class="headerlink" title="零宽度断言(前后预查)"></a>零宽度断言(前后预查)</h2><p>先行断言和后发断言都属于<strong>非捕获簇</strong>(不捕获文本 ，也不针对组合计进行计数).其中先行断言用于判断所匹配的格式是否在另一个确定的格式之前, 匹配结果不包含该确定格式(仅作为约束).</p>
<p>这段定义依然文理艰深，晦涩难懂。下面我们结合具体案例进行分析：若想获得所有在 <code>$</code> 符号后的数字, 我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>.<br>这个表达式匹配 <code>$</code> 开头, 之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符出现大于等于 0 次的字符串.</p>
<p>现将零宽度断言列举如下，下面我们将逐一介绍。</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">?=</td>
<td>正先行断言-存在</td>
</tr>
<tr>
<td align="center">?!</td>
<td>负先行断言-排除</td>
</tr>
<tr>
<td align="center">?&lt;=</td>
<td>正后发断言-存在</td>
</tr>
<tr>
<td align="center">?&lt;!</td>
<td>负后发断言-排除</td>
</tr>
</tbody></table>
<h3 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=... 正先行断言"></a><code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言, 表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式，其返回结果只包含满足匹配条件的第一部分表达式.值得指出的是，定义一个正先行断言要使用 <code>()</code>. 在括号内部使用一个问号和等号: <code>(?=...)</code>. 还应当注意：正先行断言的内容写在括号中的等号后面.</p>
<p>例如, 表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ,即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>.</p>
<pre>
"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<h3 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!... 负先行断言"></a><code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果, 筛选条件为 其后<strong>不跟随着断言中定义的格式.</strong><br><code>正先行断言</code>  定义和 <code>负先行断言</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>.</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code>.</p>
<pre>
"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<h3 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;= ... 正后发断言"></a><code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为 <strong>其前跟随着断言中定义的格式.</strong><br>例如, 表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>, 且其前跟着 <code>The</code> 或 <code>the</code>.</p>
<pre>
"(?<=(t|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.
</=(t|t)he\s)(fat|mat)"></pre>

<h3 id="lt-负后发断言"><a href="#lt-负后发断言" class="headerlink" title="?&lt;!... 负后发断言"></a><code>?&lt;!...</code> 负后发断言</h3><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为 其前不跟随着断言中定义的格式.<br>例如, 表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code>.</p>
<pre>
"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.
</pre>

<h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫模式修正符, 因为它可以用来修改表达式的搜索结果.<br>这些标志可以任意的组合使用, 它也是整个正则表达式的一部分.下面我们将分别介绍这些标志</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td>忽略大小写.</td>
</tr>
<tr>
<td align="center">g</td>
<td>全局搜索.</td>
</tr>
<tr>
<td align="center">m</td>
<td>多行的: 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始.</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，使用标志时，要用/  /将标志与前文隔开使用，在下面的案例中我们将很好的体验到这一点。</p>
</blockquote>
<h3 id="忽略大小写-Case-Insensitive"><a href="#忽略大小写-Case-Insensitive" class="headerlink" title="忽略大小写 (Case Insensitive)"></a>忽略大小写 (Case Insensitive)</h3><p>修饰语 <code>i</code> 用于忽略大小写.<br>例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 不区分大小写的字母<code>the</code> , <code>g</code> 表示全局搜索.</p>
<pre>
"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.
</pre>

<pre>
"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.
</pre>

<h3 id="全局搜索-Global-search"><a href="#全局搜索-Global-search" class="headerlink" title="全局搜索 (Global search)"></a>全局搜索 (Global search)</h3><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配, 即(不仅仅返回第一个匹配的, 而是返回全部).<br>例如, 表达式 <code>/.(at)/g</code> 表示搜索 任意字符(除了换行) + <code>at</code>, 并返回全部结果.</p>
<pre>
"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.
</pre>

<pre>
"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.
</pre>

<h3 id="多行修饰符-Multiline"><a href="#多行修饰符-Multiline" class="headerlink" title="多行修饰符 (Multiline)"></a>多行修饰符 (Multiline)</h3><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配.</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾. 但我们如果想要它在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code>.</p>
<p>例如, 表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> , 末尾可选除换行符外任意字符. 根据 <code>m</code> 修饰符, 现在表达式匹配每行的结尾.</p>
<blockquote>
<p>也就是说，在不加入多行修饰符的情况下，多行字符的末尾默认是整个字符串结尾，而加入修饰符后，每一行末尾都被视为一个行尾</p>
</blockquote>
<pre>
"/.at(.)?$/" => The fat
                cat sat
                on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<pre>
"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>
                  cat <a href="#learn-regex"><strong>sat</strong></a>
                  on the <a href="#learn-regex"><strong>mat.</strong></a>
</pre>

<h2 id="贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h2><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<p>关于贪婪匹配和惰性匹配，相信下面的这组案例将会很好的让我们理解二者区别。</p>
<pre>
"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre>

<pre>
"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre>

<h2 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a>正则表达式的应用</h2><p>在知乎的正则表达式有关话题下，我看到有人提及正则表达式十分精妙，但也有一些说正则表达式在实际编程中应用并不广泛。但其实，借助正则表达式，我们完全可以做到很多事情——可以完成各种复杂格式字符串格式校验(如手机号、身份证号、文件名称、地址名称、邮箱号码等)，还在网络爬虫，数据清洗等很多领域有着独特的应用。受篇幅所限，在本文中我们将不再详细展开介绍，有兴趣的朋友们可以自行深入研究。有机会的话，我将在未来继续分享正则表达式在实际编程环境下的一系列应用。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Ding Zhi</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://dingzhi.ga/articles/regex-1/">http://dingzhi.ga/articles/regex-1/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Attribution-NonCommercial-NoDerivs 3.0 Unported <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" rel="external nofollow">(CC BY-NC-ND 3.0)</a></span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/正则表达式/"># 正则表达式</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/articles/numpy/">国外大神制作的超棒NumPy可视化教程</a>
            
            
            <a class="next" rel="next" href="/articles/Python-DataScience-1/">数据科学学习笔记|实例1-图像的手绘效果</a>
            
        </section>


    </article>
</div>


        </div>
        <footer id="footer" class="footer">
    <title>打赏</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!--<script type="text/javascript" src="http://static.tctip.com/tctip-1.0.2.js"></script>-->
<script type="text/javascript" src="http://dingzhi.ga/js/tctip-1.0.3.min.js"></script>
<script>
  new tctip({
    top: '20%',
    button: {
      id: 9,
      type: 'dashang'
    },
    list: [
      {
        type: 'alipay',
        qrImg: 'http://dingzhi.ga/images/alipay.jpg'
      }, {
        type: 'wechat',
        qrImg: 'http://dingzhi.ga/images/wechat.jpg'
      }
    ]
  }).init()
</script>
友情链接<span lang="EN-US"> | <a href="http://fenghe.us/" target="_blank">Fenghe's
Blog |</a>
<a href="http://www.kamzero.cn" target="_blank">Sherry's
Blog |</a>
<span>© Ding Zhi 2019 | All Rights Reserved</span>
</span></footer>
    </div>
</body>
</html>
